import { BaseContextModule } from '@stratix/runtime';
import type {
  PluginMetadata,
  CommandDefinition,
  QueryDefinition,
  EventHandlerDefinition,
  RepositoryDefinition,
  PluginContext,
} from '@stratix/abstractions';
import { Create<%- entityName %>Command } from './application/commands/Create<%- entityName %>.js';
import { Create<%- entityName %>Handler } from './application/commands/Create<%- entityName %>Handler.js';
import { Get<%- entityName %>ByIdQuery } from './application/queries/Get<%- entityName %>ById.js';
import { Get<%- entityName %>ByIdHandler } from './application/queries/Get<%- entityName %>ByIdHandler.js';
import { List<%- entityNamePlural %>Query } from './application/queries/List<%- entityNamePlural %>.js';
import { List<%- entityNamePlural %>Handler } from './application/queries/List<%- entityNamePlural %>Handler.js';
import { InMemory<%- entityName %>Repository } from './infrastructure/persistence/InMemory<%- entityName %>Repository.js';
import type { <%- entityName %>Repository } from './domain/repositories/<%- entityName %>Repository.js';

/**
 * <%- contextName %> Bounded Context Module.
 *
 * This module encapsulates the entire <%- contextName %> bounded context including:
 * - Domain entities, value objects, and events
 * - Application commands and queries with handlers
 * - Infrastructure repositories
 *
 * The module can be deployed as:
 * - Part of a monolith (alongside other context modules)
 * - Standalone microservice (only this context)
 *
 * To switch from monolith to microservice, only change infrastructure
 * plugins in main.ts - NO changes needed to this context code.
 */
export class <%- contextName %>ContextModule extends BaseContextModule {
  readonly metadata: PluginMetadata = {
    name: '<%- contextNameKebab %>-context',
    version: '1.0.0',
    description: '<%- contextName %> Bounded Context',
    dependencies: [],
  };

  readonly contextName = '<%- contextName %>';

  private <%- entityNameCamel %>Repository!: <%- entityName %>Repository;

  /**
   * Returns all command definitions for the <%- contextName %> context.
   */
  getCommands(): CommandDefinition[] {
    return [
      {
        name: 'Create<%- entityName %>',
        commandType: Create<%- entityName %>Command,
        handler: new Create<%- entityName %>Handler(this.<%- entityNameCamel %>Repository),
      },
    ];
  }

  /**
   * Returns all query definitions for the <%- contextName %> context.
   */
  getQueries(): QueryDefinition[] {
    return [
      {
        name: 'Get<%- entityName %>ById',
        queryType: Get<%- entityName %>ByIdQuery,
        handler: new Get<%- entityName %>ByIdHandler(this.<%- entityNameCamel %>Repository),
      },
      {
        name: 'List<%- entityNamePlural %>',
        queryType: List<%- entityNamePlural %>Query,
        handler: new List<%- entityNamePlural %>Handler(this.<%- entityNameCamel %>Repository),
      },
    ];
  }

  /**
   * Returns all event handler definitions for the <%- contextName %> context.
   */
  getEventHandlers(): EventHandlerDefinition[] {
    // Add event handlers here when needed
    return [];
  }

  /**
   * Returns all repository definitions for the <%- contextName %> context.
   */
  getRepositories(): RepositoryDefinition[] {
    return [
      {
        token: '<%- entityNameCamel %>Repository',
        instance: new InMemory<%- entityName %>Repository(),
        singleton: true,
      },
    ];
  }

  /**
   * Initialize the <%- contextName %> context module.
   *
   * Repositories are registered first by the base class, so we can
   * resolve them here before registering commands/queries.
   */
  async initialize(context: PluginContext): Promise<void> {
    // Resolve repositories from container (registered by base class)
    this.<%- entityNameCamel %>Repository = context.container.resolve<<%- entityName %>Repository>(
      '<%- entityNameCamel %>Repository'
    );

    // Call super to auto-register all commands, queries, and event handlers
    await super.initialize(context);
  }
}
